within ;
model TestOverWrite_ExportedModel_fmu
extends fmuIcon;
// Model automatically generated by Dymola from FMI model description
public
  parameter Boolean _block_jacobian_check = false;
  parameter Real _block_jacobian_check_tol = 1.0E-6;
  parameter Integer _block_solver_experimental_mode = 0;
  parameter Boolean _block_solver_profiling = false;
  parameter Integer _cs_experimental_mode = 0;
  parameter Real _cs_rel_tol = 1.0E-6;
  parameter Integer _cs_solver = 0;
  parameter Real _cs_step_size = 0.001;
  parameter Boolean _enforce_bounds = true;
  parameter Real _events_default_tol = 1.0E-10;
  parameter Real _events_tol_factor = 1.0E-4;
  parameter Integer _iteration_variable_scaling = 1;
  parameter Integer _log_level = 3;
  parameter Integer _nle_active_bounds_mode = 0;
  parameter Boolean _nle_brent_ignore_error = false;
  parameter Integer _nle_jacobian_calculation_mode = 0;
  parameter Real _nle_jacobian_finite_difference_delta = 1.490116119384766E-8;
  parameter Integer _nle_jacobian_update_mode = 2;
  parameter Boolean _nle_solver_check_jac_cond = false;
  parameter Real _nle_solver_default_tol = 1.0E-10;
  parameter Integer _nle_solver_exit_criterion = 3;
  parameter Integer _nle_solver_max_iter = 100;
  parameter Integer _nle_solver_max_iter_no_jacobian = 10;
  parameter Real _nle_solver_max_residual_scaling_factor = 1.0E10;
  parameter Real _nle_solver_min_residual_scaling_factor = 1.0E-10;
  parameter Real _nle_solver_min_tol = 1.0E-12;
  parameter Real _nle_solver_regularization_tolerance = -1.0;
  parameter Real _nle_solver_step_limit_factor = 10.0;
  parameter Real _nle_solver_tol_factor = 1.0E-4;
  parameter Boolean _nle_solver_use_last_integrator_step = true;
  parameter Boolean _nle_solver_use_nominals_as_fallback = true;
  parameter Boolean _rescale_after_singular_jac = true;
  parameter Boolean _rescale_each_step = false;
  parameter Integer _residual_equation_scaling = 1;
  parameter Boolean _runtime_log_to_file = false;
  parameter Real _time_events_default_tol = 2.220446049250313E-14;
  parameter Boolean _use_Brent_in_1d = true;
  parameter Boolean _use_jacobian_equilibration = false;
  parameter Boolean _use_newton_for_brent = true;
protected
  record 'mod_rec'
  protected
    record TSet_rec
      parameter Real k = 1.0
                            "Constant output value";
      parameter Real y(fixed=false)
                                   "Connector of Real output signal";
    end TSet_rec;
  public
    TSet_rec TSet annotation(Dialog);
  protected
    record conPI_rec
    protected
      record Dzero_rec
        parameter Real k = 0.0
                              "Constant output value";
        parameter Real y(fixed=false)
                                     "Connector of Real output signal";
      end Dzero_rec;
    public
      Dzero_rec Dzero annotation(Dialog);
    protected
      record I_rec
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState
                                                                                              "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
        parameter Real k(unit = "1", fixed=false)
                                                 "Integrator gain";
        Real u
              "Connector of Real input signal";
        Real y(fixed=false)
                           "Connector of Real output signal";
        parameter Real y_start(fixed=false)
                                           "Initial or guess value of output (= state)";
      end I_rec;
    public
      I_rec I;
      parameter Real Nd(min = 1.0E-13) = 10.0
                                             "The higher Nd, the more ideal the derivative block";
      parameter Real Ni(min = 1.0E-13) = 0.9
                                            "Ni*Ti is time constant of anti-windup compensation";
    protected
      record P_rec
        parameter Real k(unit = "1") = 1.0
                                          "Gain value multiplied with input signal";
        Real u
              "Input signal connector";
        Real y
              "Output signal connector";
      end P_rec;
    public
      P_rec P annotation(Dialog);
      parameter Real Td(unit = "s", quantity = "Time", min = 0) = 0.1
                                                                     "Time constant of Derivative block";
      parameter Real Ti(unit = "s", quantity = "Time", min = 1.0E-60) = 0.5
                                                                           "Time constant of Integrator block";
    protected
      record addI_rec
        parameter Real k1 = 1.0
                               "Gain of upper input";
        parameter Real k2 = -1.0
                                "Gain of middle input";
        parameter Real k3 = 1.0
                               "Gain of lower input";
        Real u1
               "Connector 1 of Real input signals";
        Real u2
               "Connector 2 of Real input signals";
        Real u3
               "Connector 3 of Real input signals";
        Real y
              "Connector of Real output signals";
      end addI_rec;
    public
      addI_rec addI annotation(Dialog);
    protected
      record addP_rec
        parameter Real k1(fixed=false)
                                      "Gain of upper input";
        parameter Real k2 = -1.0
                                "Gain of lower input";
        Real u1
               "Connector of Real input signal 1";
        Real u2
               "Connector of Real input signal 2";
        Real y
              "Connector of Real output signal";
      end addP_rec;
    public
      addP_rec addP annotation(Dialog);
    protected
      record addPID_rec
        parameter Real k1 = 1.0
                               "Gain of upper input";
        parameter Real k2 = 1.0
                               "Gain of middle input";
        parameter Real k3 = 1.0
                               "Gain of lower input";
        Real u1
               "Connector 1 of Real input signals";
        parameter Real u2(fixed=false)
                                      "Connector 2 of Real input signals";
        Real u3
               "Connector 3 of Real input signals";
        Real y
              "Connector of Real output signals";
      end addPID_rec;
    public
      addPID_rec addPID annotation(Dialog);
    protected
      record addSat_rec
        parameter Real k1 = 1.0
                               "Gain of upper input";
        parameter Real k2 = -1.0
                                "Gain of lower input";
        Real u1
               "Connector of Real input signal 1";
        Real u2
               "Connector of Real input signal 2";
        Real y
              "Connector of Real output signal";
      end addSat_rec;
    public
      addSat_rec addSat annotation(Dialog);
      Real controlError
                       "Control error (set point - measurement)";
      constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.PI
                                                                                                                "Type of controller";
    protected
      record gainPID_rec
        parameter Real k(unit = "1", fixed=false)
                                                 "Gain value multiplied with input signal";
        Real u
              "Input signal connector";
        Real y
              "Output signal connector";
      end gainPID_rec;
    public
      gainPID_rec gainPID;
    protected
      record gainTrack_rec
        parameter Real k(unit = "1", fixed=false)
                                                 "Gain value multiplied with input signal";
        Real u
              "Input signal connector";
        Real y
              "Output signal connector";
      end gainTrack_rec;
    public
      gainTrack_rec gainTrack;
      constant Modelica.Blocks.Types.InitPID initType = Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState
                                                                                                                     "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
      parameter Real k(unit = "1", min = 0) = 1.0
                                                 "Gain of controller";
    protected
      record limiter_rec
        constant Boolean limitsAtInit = true
                                            "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)";
        constant Boolean strict = false
                                       "= true, if strict limits with noEvent(..)";
        Real u
              "Connector of Real input signal";
        parameter Real uMax = 10.0
                                  "Upper limits of input signals";
        parameter Real uMin = -10.0
                                   "Lower limits of input signals";
        Real y
              "Connector of Real output signal";
      end limiter_rec;
    public
      limiter_rec limiter annotation(Dialog);
      constant Boolean limitsAtInit = true
                                          "= false, if limits are ignored during initialization";
      constant Boolean strict = false
                                     "= true, if strict limits with noEvent(..)";
      Real u_m
              "Connector of measurement input signal";
      Real u_s
              "Connector of setpoint input signal";
      constant Real unitTime(unit = "s", quantity = "Time") = 1.0;
      parameter Real wd(min = 0) = 0.0
                                      "Set-point weight for Derivative block (0..1)";
      constant Boolean with_D = false;
      constant Boolean with_I = true;
      parameter Real wp(min = 0) = 1.0
                                      "Set-point weight for Proportional block (0..1)";
      parameter Real xd_start = 0.0
                                   "Initial or guess value for state of derivative block";
      parameter Real xi_start = 0.0
                                   "Initial or guess value value for integrator output (= integrator state)";
      Real y
            "Connector of actuator output signal";
      constant Real yMax = 10.0
                               "Upper limit of output";
      constant Real yMin = -10.0
                                "Lower limit of output";
      constant Real y_start = 0.0
                                 "Initial value of output";
    end conPI_rec;
  public
    conPI_rec conPI annotation(Dialog);
  protected
    record firOrd_rec
      parameter Real T(unit = "s", quantity = "Time") = 1.0
                                                           "Time Constant";
      constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialOutput
                                                                                             "Type of initialization (1: no init, 2: steady state, 3/4: initial output)";
      parameter Real k(unit = "1") = 1.0
                                        "Gain";
      Real u
            "Connector of Real input signal";
      Real y(fixed=false)
                         "Connector of Real output signal";
      parameter Real y_start = 0.0
                                  "Initial or guess value of output (= state)";
    end firOrd_rec;
  public
    firOrd_rec firOrd annotation(Dialog);
  protected
    record oveWriAct_rec
    protected
      record activate_rec
        Boolean y
                 "Value of Boolean output";
      end activate_rec;
    public
      activate_rec activate;
    protected
      record swi_rec
        Real u1
               "Connector of first Real input signal";
        Boolean u2
                  "Connector of Boolean input signal";
        Real u3
               "Connector of second Real input signal";
        Real y
              "Connector of Real output signal";
      end swi_rec;
    public
      swi_rec swi;
      Real u
            "Connector of Real input signal";
    protected
      record uExt_rec
        Real y
              "Value of Real output";
      end uExt_rec;
    public
      uExt_rec uExt;
      Real y
            "Connector of Real output signal";
    end oveWriAct_rec;
  public
    oveWriAct_rec oveWriAct;
  protected
    record oveWriSet_rec
    protected
      record activate_rec
        Boolean y
                 "Value of Boolean output";
      end activate_rec;
    public
      activate_rec activate;
    protected
      record swi_rec
        Real u1
               "Connector of first Real input signal";
        Boolean u2
                  "Connector of Boolean input signal";
        parameter Real u3(fixed=false)
                                      "Connector of second Real input signal";
        Real y
              "Connector of Real output signal";
      end swi_rec;
    public
      swi_rec swi;
      parameter Real u(fixed=false)
                                   "Connector of Real input signal";
    protected
      record uExt_rec
        Real y
              "Value of Real output";
      end uExt_rec;
    public
      uExt_rec uExt;
      Real y
            "Connector of Real output signal";
    end oveWriSet_rec;
  public
    oveWriSet_rec oveWriSet;
  protected
    record rea_rec
      Real u
            "Connector of Real input signal";
      Real y
            "Connector of Real output signal";
    end rea_rec;
  public
    rea_rec rea annotation(Dialog);
  end 'mod_rec';
public
  'mod_rec' 'mod' annotation(Dialog);
  parameter Boolean _oveWriAct_activate_start = false
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.BooleanInput oveWriAct_activate(start = _oveWriAct_activate_start)
                                                                                               "Activation for overwrite block for actuator signal"
  annotation (Placement(transformation(extent={{-124,40},{-84,80}})));
  parameter Real _oveWriAct_u_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput oveWriAct_u(start = _oveWriAct_u_start)
                                                                              "Signal for overwrite block for actuator signal"
  annotation (Placement(transformation(extent={{-124,0},{-84,40}})));
  parameter Boolean _oveWriSet_activate_start = false
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.BooleanInput oveWriSet_activate(start = _oveWriSet_activate_start)
                                                                                               "Activation for overwrite block for set point"
  annotation (Placement(transformation(extent={{-124,-40},{-84,0}})));
  parameter Real _oveWriSet_u_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput oveWriSet_u(start = _oveWriSet_u_start)
                                                                              "Signal for overwrite block for set point"
  annotation (Placement(transformation(extent={{-124,-80},{-84,-40}})));
  Modelica.Blocks.Interfaces.RealOutput rea
                                           "Measured state variable"
  annotation (Placement(transformation(extent={{100,-20},{140,20}})));
public
  parameter String fmi_instanceName="TestOverWrite_ExportedModel_fmu"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  parameter String fmi_resourceLocation="file:///"+ModelicaServices.ExternalReferences.loadResource("modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/resources")
  annotation (Dialog(tab="FMI", group="Instantiation"));
protected
  constant Integer fmi_NumberOfEventIndicators = 2;
  Real fmi_z[fmi_NumberOfEventIndicators] "Event indicators";
  Boolean fmi_z_positive[fmi_NumberOfEventIndicators](each start=false, fixed=true);
  fmi_Functions.fmiModel fmi;
  parameter Real zeroOffset = 0; //will fix in later implementations
  Boolean fmi_NewStates;
  Boolean fmi_StepEvent;
  Boolean fmi_DiscreteInputChanged;
  Boolean fmi_iterationConverged(start=false, fixed=true);
  Integer fmi_NextMode;
  Boolean fmi_flip(start=false, fixed=true);
  Real fmi_TNext(start=1e37, fixed=true);
  Real myTime;
  parameter Real myTimeStart(fixed=false);
  Boolean _first(start=true);
  parameter Boolean _startValuesNotSet(fixed=false,start=true);
  Real fmi_dummy;
package fmi_Functions
    class fmiModel
      extends ExternalObject;
      function constructor "Initialize FMI model"
        extends Modelica.Icons.Function;
        input String instanceName;
        input Boolean loggingOn;
        input String resourceLocation;
        output fmiModel fmi;
        external"C" fmi = TestOverWrite_ExportedModel_fmiInstantiateModel2(instanceName, loggingOn, resourceLocation)
        annotation(Header="
#ifndef TestOverWrite_ExportedModel_Instantiate_C
#define TestOverWrite_ExportedModel_Instantiate_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void TestOverWrite_ExportedModelLogger(fmi2ComponentEnvironment componentEnvironment, fmi2String instanceName, fmi2Status status,
  fmi2String category, fmi2String message, ...) {
  char msg[4096];
  char buf[4096];
  va_list ap;
  int len;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len < 4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmi2Fatal:
      ModelicaMessage(\"[fmi2Fatal]: \");
      break;
    case fmi2Error:
      ModelicaMessage(\"[fmi2Error]: \");
      break;
    case fmi2Discard:
      ModelicaMessage(\"[fmi2Discard]: \");
      break;
    case fmi2Warning:
      ModelicaMessage(\"[fmi2Warning]: \");
      break;
    case fmi2OK:
      ModelicaMessage(\"[fmi2OK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * TestOverWrite_ExportedModel_fmiInstantiateModel2(const char*instanceName, fmi2Boolean loggingOn, fmi2String resourceLocation) {
  static fmi2CallbackFunctions funcs = {&TestOverWrite_ExportedModelLogger, &calloc, &free, NULL, NULL};
  struct dy_fmi2Extended* res;
  res = calloc(1, sizeof(struct dy_fmi2Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibrary(\"TestOverWrite_ExportedModel.so\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (TestOverWrite_ExportedModel.so) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiate=(fmi2InstantiateFunc)GetProcAddress(res->hInst,\"fmi2Instantiate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Instantiate!\");
      return 0;
    }
    if (!(res->dyFmiFreeInstance=(fmi2FreeInstanceFunc)GetProcAddress(res->hInst,\"fmi2FreeInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeInstance!\");
      return 0;
    }
    if (!(res->dyFmiSetupExperiment=(fmi2SetupExperimentFunc)GetProcAddress(res->hInst,\"fmi2SetupExperiment\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetupExperiment!\");
      return 0;
    }
    if (!(res->dyFmiEnterInitializationMode=(fmi2EnterInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2EnterInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiExitInitializationMode=(fmi2ExitInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2ExitInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2ExitInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmi2TerminateFunc)GetProcAddress(res->hInst,\"fmi2Terminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Terminate!\");
      return 0;
    }
    if (!(res->dyFmiReset=(fmi2ResetFunc)GetProcAddress(res->hInst,\"fmi2Reset\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Reset!\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmi2SetRealFunc)GetProcAddress(res->hInst,\"fmi2SetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmi2GetRealFunc)GetProcAddress(res->hInst,\"fmi2GetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmi2SetIntegerFunc)GetProcAddress(res->hInst,\"fmi2SetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmi2GetIntegerFunc)GetProcAddress(res->hInst,\"fmi2GetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmi2SetBooleanFunc)GetProcAddress(res->hInst,\"fmi2SetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmi2GetBooleanFunc)GetProcAddress(res->hInst,\"fmi2GetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmi2SetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmi2SetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetDebugLogging!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmi2SetStringFunc)GetProcAddress(res->hInst,\"fmi2SetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmi2GetStringFunc)GetProcAddress(res->hInst,\"fmi2GetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetString!\");
      return 0;
    }
    if (!(res->dyFmiSetContinuousStates=(fmi2SetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmi2SetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetContinuousStates=(fmi2GetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmi2GetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetTime=(fmi2SetTimeFunc)GetProcAddress(res->hInst,\"fmi2SetTime\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetTime!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetTime\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiCompletedIntegratorStep=(fmi2CompletedIntegratorStepFunc)GetProcAddress(res->hInst,\"fmi2CompletedIntegratorStep\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2CompletedIntegratorStep!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiCompletedIntegratorStep\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEnterEventMode=(fmi2EnterEventModeFunc)GetProcAddress(res->hInst,\"fmi2EnterEventMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterEventMode!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEnterEventMode\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiNewDiscreteStates=(fmi2NewDiscreteStatesFunc)GetProcAddress(res->hInst,\"fmi2NewDiscreteStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2NewDiscreteStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiNewDiscreteStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEnterContinuousTimeMode=(fmi2EnterContinuousTimeModeFunc)GetProcAddress(res->hInst,\"fmi2EnterContinuousTimeMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterContinuousTimeMode!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEnterContinuousTimeMode\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDerivatives=(fmi2GetDerivativesFunc)GetProcAddress(res->hInst,\"fmi2GetDerivatives\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetDerivatives!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetDerivatives\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetEventIndicators=(fmi2GetEventIndicatorsFunc)GetProcAddress(res->hInst,\"fmi2GetEventIndicators\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetEventIndicators!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetEventIndicators\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    res->m=res->dyFmiInstantiate(instanceName, fmi2ModelExchange, \"94b59c547e4c633d5c3d81dc3c331309\",resourceLocation, &funcs, fmi2False, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->discreteInputChanged=1;res->currentMode=dyfmi2InstantiationMode;res->dyLastStepTime=0;res->dyFMUstate=NULL;}
  }
  return res;
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
      end constructor;

      function destructor "Release storage of FMI model"
        extends Modelica.Icons.Function;
        input fmiModel fmi;
        external"C"
                   TestOverWrite_ExportedModel_fmiFreeModelInstance2(fmi);
        annotation (Header="
#ifndef TestOverWrite_ExportedModel_Free_C
#define TestOverWrite_ExportedModel_Free_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void TestOverWrite_ExportedModel_fmiFreeModelInstance2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    /*a->dyFmiSetDebugLogging(a->m,fmi2True,0,NULL);*/
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
      end destructor;
    end fmiModel;

    function  fmiSetTime
    input fmiModel fmi;
    input Real ti;
    external"C" TestOverWrite_ExportedModel_fmiSetTime2(fmi, ti);
    annotation (Header="
#ifndef TestOverWrite_ExportedModel_SetTime_C
#define TestOverWrite_ExportedModel_SetTime_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiSetTime2(void*m, double ti) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(ti > a->dyTime || (a->currentMode == dyfmi2EventMode && ti==a->dyTime && !isModelicaEvent())){
      a->dyTime=ti;
      if(a->currentMode == dyfmi2EventMode){
        status = a->dyFmiEnterContinuousTimeMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterContinuousTimeMode failed!\");
        a->currentMode = dyfmi2ContinuousTimeMode;
      }
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti < a->dyTime && a->currentMode == dyfmi2ContinuousTimeMode){
       a->dyTime=ti;
       status=a->dyFmiSetTime(a->m, ti);
    }else{
       status=fmi2OK;
    }
  }
  if (status!=fmi2OK ) ModelicaError(\"SetTime failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel",__Dymola_IdemPotent=true);
    end fmiSetTime;

    function fmiSetContinuousStates
    input fmiModel fmi;
    input Real x[:];
      external"C" TestOverWrite_ExportedModel_fmiSetContinuousStates2(
       fmi,
       x,
       size(x, 1));
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_SetContinuousStates_C
#define TestOverWrite_ExportedModel_SetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiSetContinuousStates2(void*m, const double*x, size_t nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
     status=a->dyFmiSetContinuousStates(a->m, x, nx);
    }else{
     status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetContinuousStates failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiSetContinuousStates;

    function  fmiGetContinuousStates
    input fmiModel fmi;
    input Integer nx;
    output Real x[nx];
    input Real preAvailable;
      external"C" TestOverWrite_ExportedModel_fmiGetContinuousStates2(
        fmi,
        x,
        nx);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_GetContinuousStates_C
#define TestOverWrite_ExportedModel_GetContinuousStates_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void TestOverWrite_ExportedModel_fmiGetContinuousStates2(void*m, double*x, int nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetContinuousStates(a->m, x, nx);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetContinuousStates failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiGetContinuousStates;

    function  fmiCompletedIntegratorStep
    input fmiModel fmi;
    input Real dummyTime;
    output Real crossing;
      external"C" crossing = TestOverWrite_ExportedModel_fmiCompletedIntegratorStep2(fmi);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_CompletedIntegratorStep_C
#define TestOverWrite_ExportedModel_CompletedIntegratorStep_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double TestOverWrite_ExportedModel_fmiCompletedIntegratorStep2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status = fmi2Fatal;
  fmi2Boolean enterEventMode = fmi2False;
  fmi2Boolean terminateSimulation = fmi2False;
  if (a) {
    if (a->dyTime>a->dyLastTime) {
      status=a->dyFmiCompletedIntegratorStep(a->m, fmi2True, &enterEventMode, &terminateSimulation);
      if(terminateSimulation == fmi2True) terminate(\"Terminate signaled by FMU after call to fmiCompletedIntegratorStep\");
      a->dyLastTime=a->dyTime;
      if (enterEventMode == fmi2True) a->dyTriggered=1;
    } else status=fmi2OK;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"CompletedIntegratorStep failed\");
  return a->dyTriggered && a->dyTime>=a->dyLastTime;
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiCompletedIntegratorStep;

    function  fmiEnterModelInitialization
    input fmiModel fmi;
    input Real startTime;
    external"C" TestOverWrite_ExportedModel_fmiEnterModelInitialization2(fmi, startTime);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_fmiEnterModelInitialization_C
#define TestOverWrite_ExportedModel_fmiEnterModelInitialization_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiEnterModelInitialization2(void*m, double startTime) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  fmi2Boolean toleranceControlled=fmi2False;
  fmi2Real tolerance=0;
  if (a) {
    if(a->currentMode==dyfmi2InstantiationMode){
      a->dyTime=startTime;
      status=a->dyFmiSetupExperiment(a->m, fmi2False, 0, a->dyTime, fmi2False, 0);
      status=a->dyFmiEnterInitializationMode(a->m);
      a->currentMode=dyfmi2InitializationMode;
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
    }else{
      status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"Initialize failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiEnterModelInitialization;

    function  fmiExitModelInitializationMode
    input fmiModel fmi;
    output Real dummy=1.0;
    external"C" TestOverWrite_ExportedModel_fmiExitModelInitializationMode2(fmi);
    annotation (Header="
#ifndef TestOverWrite_ExportedModel_fmiExitModelInitializationMode_C
#define TestOverWrite_ExportedModel_fmiExitModelInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiExitModelInitializationMode2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiExitInitializationMode(a->m);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
    a->currentMode = dyfmi2EventMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiExitModelInitialization failed!\");
  return;
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiExitModelInitializationMode;

    function  fmiUpdateDiscreteStates
    input fmiModel fmi;
    output Integer nextMode;
    output Real tNext;
    output Boolean stateValuesChanged;
    external"C" nextMode = TestOverWrite_ExportedModel_fmiUpdateDiscreteStates2(fmi, tNext, stateValuesChanged);
      annotation(Header="
#ifndef TestOverWrite_ExportedModel_UpdateDiscreteStates_C
#define TestOverWrite_ExportedModel_UpdateDiscreteStates_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
int TestOverWrite_ExportedModel_fmiUpdateDiscreteStates2(void*m, double* tNext, int* stateValuesChanged){
  struct dy_fmi2Extended*a=m;
  fmi2EventInfo ev;
  fmi2Status status=fmi2Fatal;
  ev.nextEventTime=1e37;
  ev.newDiscreteStatesNeeded=fmi2False;
  ev.valuesOfContinuousStatesChanged=fmi2False;
  ev.nextEventTimeDefined=fmi2False;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
  status=a->dyFmiNewDiscreteStates(a->m, &ev);
  a->dyTriggered=0;
  a->dyLastTime=a->dyTime;
  a->discreteInputChanged=0;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"EventUpdate failed\");
  if (ev.terminateSimulation){
    terminate(\"Terminate signaled by FMU\");
  }
  if(ev.nextEventTimeDefined==fmi2True){
    *tNext=ev.nextEventTime;
  }else{
    *tNext=1e37;
  }
  *stateValuesChanged = ev.valuesOfContinuousStatesChanged;
  return ev.newDiscreteStatesNeeded;
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiUpdateDiscreteStates;

    function  fmiGetDerivatives
    input fmiModel fmi;
    input Integer nx;
    output Real dx[nx];
    external"C" TestOverWrite_ExportedModel_fmiGetDerivatives2(
    fmi,
      dx,
      nx);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_GetDerivatives_C
#define TestOverWrite_ExportedModel_GetDerivatives_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiGetDerivatives2(void*m,double*dx,int nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetDerivatives(a->m, dx, nx);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetDerivatives failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiGetDerivatives;

    function  fmiGetEventIndicators
    input fmiModel fmi;
    input Integer nz;
    output Real z[nz];
    external"C" TestOverWrite_ExportedModel_fmiGetEventIndicators2(
      fmi,
      z,
      nz);
    annotation (Header="
#ifndef TestOverWrite_ExportedModel_GetEventIndicators_C
#define TestOverWrite_ExportedModel_GetEventIndicators_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiGetEventIndicators2(void*m,double*z,int nz) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode || a->currentMode == dyfmi2EventMode){
      status=a->dyFmiGetEventIndicators(a->m, z, nz);
    }else{
      status=fmi2OK;    }
;  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetEventIndicators failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiGetEventIndicators;

    function fmiReset
      input fmiModel fmi;
      output Boolean resetOK;
      external"C" resetOK = TestOverWrite_ExportedModel_fmiReset2(fmi);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_Reset_C
#define TestOverWrite_ExportedModel_Reset_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double TestOverWrite_ExportedModel_fmiReset2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiReset(a->m);
    a->currentMode=dyfmi2InstantiationMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiReset failed\");
    return 1.0;
  }
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiReset;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      external"C" TestOverWrite_ExportedModel_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_GetReal_C
#define TestOverWrite_ExportedModel_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiGetReal;

    function fmiGetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real preAvailable;
      output Real vals[size(refs, 1)];
      external"C" TestOverWrite_ExportedModel_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_GetReal_C
#define TestOverWrite_ExportedModel_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiGetRealwf;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      external"C"
                 TestOverWrite_ExportedModel_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef TestOverWrite_ExportedModel_SetReal_C
#define TestOverWrite_ExportedModel_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      input Real preAvailable;
      output Real postAvailable=preAvailable;
      external"C"
                 TestOverWrite_ExportedModel_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef TestOverWrite_ExportedModel_SetReal_C
#define TestOverWrite_ExportedModel_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealwf;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      external"C" TestOverWrite_ExportedModel_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_GetInteger_C
#define TestOverWrite_ExportedModel_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiGetInteger;

    function fmiGetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Integer vals[size(refs, 1)];
      external"C" TestOverWrite_ExportedModel_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_GetInteger_C
#define TestOverWrite_ExportedModel_GetInteger_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void TestOverWrite_ExportedModel_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiGetIntegerwf;

    function fmiSetInteger
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" TestOverWrite_ExportedModel_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_SetInteger_C
#define TestOverWrite_ExportedModel_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed in SetInteger\");
      for( i = 0; i < nrefs; ++i){
        if(oldVals[i] != vals[i]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      external"C" TestOverWrite_ExportedModel_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef TestOverWrite_ExportedModel_GetBoolean_C
#define TestOverWrite_ExportedModel_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiGetBoolean;

    function fmiGetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Boolean vals[size(refs, 1)];
      external"C" TestOverWrite_ExportedModel_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef TestOverWrite_ExportedModel_GetBoolean_C
#define TestOverWrite_ExportedModel_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiGetBooleanwf;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" TestOverWrite_ExportedModel_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals);
        annotation (Header="
#ifndef TestOverWrite_ExportedModel_SetBoolean_C
#define TestOverWrite_ExportedModel_SetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals, int* dummy, int* oldVals) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(oldVals));
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed in SetBoolean\");
      for(j=nr-1;j>=0;j--){
        oldVals[j]=((fmi2Boolean*)(oldVals))[j];
        if(oldVals[j] != dummy[j]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetString
      input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" TestOverWrite_ExportedModel_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_SetString_C
#define TestOverWrite_ExportedModel_SetString_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void TestOverWrite_ExportedModel_fmiSetString2(void*m, const int*refs, size_t nrefs,const fmi2String vals[]) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    a->discreteInputChanged = fmi2True;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetString failed\");
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function CheckIfDiscreteValueSet
      input fmiModel fmi;
      input Real dummyTime;
      input Real realInputs[:];
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      input Integer realInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Real dummyRealOutputs[:];
      input Boolean dummyBooleanOutputs[:];
      input Integer dummyIntegerOutputs[:];
      output Real DiscreteInputSet;
    algorithm
      fmiSetReal(fmi, realInputValueReferences, realInputs);
      fmiSetBoolean(fmi, booleanInputValueReferences, booleanInputs);
      fmiSetInteger(fmi, integerInputValueReferences, integerInputs);
      DiscreteInputSet := fmiCheckIfDiscreteValueSet(fmi);
      annotation(LateInline=true);
    end CheckIfDiscreteValueSet;

    function fmiCheckIfDiscreteValueSet
      input fmiModel fmi;
      output Real DiscreteInputSet;
      external "C" DiscreteInputSet = TestOverWrite_ExportedModel_fmiCheckIfDiscreteValueSet2(fmi);
      annotation (Header="
#ifndef TestOverWrite_ExportedModel_fmiCheckIfDiscreteValueSet_C
#define TestOverWrite_ExportedModel_fmiCheckIfDiscreteValueSet_C 1
#include \"FMI/fmi2Import.h\"
double TestOverWrite_ExportedModel_fmiCheckIfDiscreteValueSet2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    return a->discreteInputChanged;
  }
  ModelicaError(\"fmiCheckIfDiscreteValueSet2 failed!\");
  return 0;
}
#endif", Library="TestOverWrite_ExportedModel", LibraryDirectory="modelica://TestOverWrite_ExportedModel_fmu/Resources/Library/FMU/TestOverWrite_ExportedModel/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="TestOverWrite_ExportedModel");
    end fmiCheckIfDiscreteValueSet;

    function GetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1]);
      annotation(LateInline=true);
    end GetRealVariable;

    function GetEventIndicators
      input fmiModel fmi;
      input Integer nz;
      output Real z[nz];
      input Real dummyTime;
      input Real realInputs[:];
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputVariableReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      z := fmiGetEventIndicators(fmi, nz);
      annotation(LateInline=true);
    end GetEventIndicators;

    function noHysteresis
      input Real x;
      output Real y;
    algorithm
      y:=x+(if (x < 0) then -1 else 1);
    end noHysteresis;

    function  setTimeAndStates
      input fmiModel fmu;
      input Real Time;
      input Real States[:];
      input Real dummy;
      output Real tOut=Time;
    algorithm
      fmiSetTime(fmu, Time);
      fmiSetContinuousStates(fmu,States);
      annotation(derivative(noDerivative=dummy,noDerivative=States)=dTS);
    end setTimeAndStates;

    function  dTS
      input fmiModel fmu;
      input Real Time;
      input Real States[:];
      input Real dummy;
      input Real dTime;
      output Real dt;
    algorithm
      dt:=1;
      annotation(derivative(order=2)=ddTS);
    end dTS;

    function  ddTS
      input fmiModel fmu;
      input Real Time;
      input Real States[:];
      input Real dummy;
      input Real dTime;
      input Real ddTime;
      output Real ddt;
    algorithm
      ddt:=0;
    end ddTS;
end fmi_Functions;
algorithm
  when initial() then
    if _first then
      _first := false;
      fmi := fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn, fmi_resourceLocation);
    end if;
  end when;
initial algorithm
  if _startValuesNotSet then
  fmi_Functions.fmiSetReal(fmi, {27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 1, 23, 8, 7, 12, 4, 3, 16, 17, 18, 11, 13, 14, 15, 19, 20, 2, 21, 22, 6, 5, 10, 9, 25, 24, 26}, {_block_jacobian_check_tol, _cs_rel_tol, _cs_step_size, _events_default_tol, _events_tol_factor, _nle_jacobian_finite_difference_delta, _nle_solver_default_tol, _nle_solver_max_residual_scaling_factor, _nle_solver_min_residual_scaling_factor, _nle_solver_min_tol, _nle_solver_regularization_tolerance, _nle_solver_step_limit_factor, _nle_solver_tol_factor, _time_events_default_tol, 'mod'.TSet.k, 'mod'.conPI.Dzero.k, 'mod'.conPI.Nd, 'mod'.conPI.Ni, 'mod'.conPI.P.k, 'mod'.conPI.Td, 'mod'.conPI.Ti, 'mod'.conPI.addI.k1, 'mod'.conPI.addI.k2, 'mod'.conPI.addI.k3, 'mod'.conPI.addP.k2, 'mod'.conPI.addPID.k1, 'mod'.conPI.addPID.k2, 'mod'.conPI.addPID.k3, 'mod'.conPI.addSat.k1, 'mod'.conPI.addSat.k2, 'mod'.conPI.k, 'mod'.conPI.limiter.uMax, 'mod'.conPI.limiter.uMin, 'mod'.conPI.wd, 'mod'.conPI.wp, 'mod'.conPI.xd_start, 'mod'.conPI.xi_start, 'mod'.firOrd.T, 'mod'.firOrd.k, 'mod'.firOrd.y_start});
  fmi_Functions.fmiSetBoolean(fmi, {536870982, 536870983, 536870984, 536870985, 536870986, 536870987, 536870988, 536870989, 536870990, 536870991, 536870992, 536870993, 536870994}, {_block_jacobian_check, _block_solver_profiling, _enforce_bounds, _nle_brent_ignore_error, _nle_solver_check_jac_cond, _nle_solver_use_last_integrator_step, _nle_solver_use_nominals_as_fallback, _rescale_after_singular_jac, _rescale_each_step, _runtime_log_to_file, _use_Brent_in_1d, _use_jacobian_equilibration, _use_newton_for_brent});
  fmi_Functions.fmiSetInteger(fmi, {268435510, 268435511, 268435512, 268435513, 268435514, 268435515, 268435516, 268435517, 268435518, 268435519, 268435520, 268435521}, {_block_solver_experimental_mode, _cs_experimental_mode, _cs_solver, _iteration_variable_scaling, _log_level, _nle_active_bounds_mode, _nle_jacobian_calculation_mode, _nle_jacobian_update_mode, _nle_solver_exit_criterion, _nle_solver_max_iter, _nle_solver_max_iter_no_jacobian, _residual_equation_scaling});
  fmi_Functions.fmiSetReal(fmi, {90, 89}, {_oveWriAct_u_start, _oveWriSet_u_start});
  fmi_Functions.fmiSetBoolean(fmi, {536871022, 536871021}, {_oveWriAct_activate_start, _oveWriSet_activate_start});
  fmi_Functions.fmiEnterModelInitialization(fmi, time);
  _startValuesNotSet :=false;
  end if;
  myTimeStart := time;
initial equation
equation
  when not initial() then
    fmi_dummy = fmi_Functions.fmiExitModelInitializationMode(fmi);
  end when;
  myTime = fmi_Functions.setTimeAndStates(fmi, time, {'mod'.conPI.I.y, 'mod'.firOrd.y}, fmi_dummy);
  fmi_StepEvent = fmi_Functions.fmiCompletedIntegratorStep(fmi, myTime)>0.5;
  fmi_DiscreteInputChanged= fmi_Functions.CheckIfDiscreteValueSet(fmi, myTime, {oveWriAct_u, oveWriSet_u}, {oveWriAct_activate, oveWriSet_activate}, fill(0,0), {90, 89}, {536871022, 536871021}, fill(0,0), {rea}, fill(false,0), fill(0,0))  > 0.5;
  fmi_flip = ( if ( fmi_DiscreteInputChanged or not pre(fmi_iterationConverged)) then not pre(fmi_flip) else pre(fmi_flip));
  fmi_z  = fmi_Functions.GetEventIndicators(fmi, fmi_NumberOfEventIndicators, myTime, {oveWriAct_u, oveWriSet_u}, {oveWriAct_activate, oveWriSet_activate}, fill(0,0), {90, 89}, {536871022, 536871021}, fill(0,0));
  for i in 1:size(fmi_z,1) loop
    fmi_z_positive[i] = fmi_Functions.noHysteresis(fmi_z[i]) > 0;
  end for;
  when cat(1, change(fmi_z_positive), {time>=pre(fmi_TNext), fmi_flip, not fmi_flip, fmi_StepEvent}) then
    (fmi_NextMode, fmi_TNext, fmi_NewStates) =  fmi_Functions.fmiUpdateDiscreteStates(fmi);
    fmi_iterationConverged = if fmi_NextMode == 0 then true else false;
{'mod'.oveWriAct.activate.y, 'mod'.oveWriSet.activate.y} = fmi_Functions.fmiGetBooleanwf(fmi, {536871020, 536871019}, if initial() then integer(myTimeStart) else integer(myTime));
  end when;
initial equation
  'mod'.TSet.y = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.TSet.k}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {1}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {49});
  'mod'.conPI.Dzero.y = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.conPI.Dzero.k}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {23}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {50});
  'mod'.conPI.I.k = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.conPI.Ti}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {3}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {45});
  'mod'.conPI.I.y = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.conPI.xi_start}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {9}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {87});
  'mod'.conPI.I.y_start = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.conPI.xi_start}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {9}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {46});
  'mod'.conPI.addP.k1 = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.conPI.wp}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {5}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {44});
  'mod'.conPI.addPID.u2 = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.conPI.Dzero.k}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {23}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {53});
  'mod'.conPI.gainPID.k = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.conPI.k}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {2}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {47});
  'mod'.conPI.gainTrack.k = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.conPI.Ni, 'mod'.conPI.k}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {7, 2}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {48});
  'mod'.firOrd.y = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.firOrd.y_start}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {26}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {88});
  'mod'.oveWriSet.swi.u3 = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.TSet.k}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {1}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {52});
  'mod'.oveWriSet.u = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.TSet.k}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {1}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {51});
equation
  if initial() then
    der('mod'.conPI.I.y) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.TSet.k, 'mod'.conPI.Dzero.k, 'mod'.conPI.Ni, 'mod'.conPI.P.k, 'mod'.conPI.Ti, 'mod'.conPI.addI.k1, 'mod'.conPI.addI.k2, 'mod'.conPI.addI.k3, 'mod'.conPI.addP.k2, 'mod'.conPI.addPID.k1, 'mod'.conPI.addPID.k2, 'mod'.conPI.addPID.k3, 'mod'.conPI.addSat.k1, 'mod'.conPI.addSat.k2, 'mod'.conPI.k, 'mod'.conPI.limiter.uMax, 'mod'.conPI.limiter.uMin, 'mod'.conPI.wp, 'mod'.conPI.xi_start, 'mod'.firOrd.y_start, oveWriSet_u}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {oveWriSet_activate}, fill(0,0), {1, 23, 7, 12, 3, 16, 17, 18, 11, 13, 14, 15, 19, 20, 2, 21, 22, 5, 9, 26, 89}, fill(0,0), fill(0,0), {536871021}, fill(0,0), {85});
  else
    der('mod'.conPI.I.y) = fmi_Functions.GetRealVariable(fmi, myTime, {oveWriSet_u}, fill(0.0,0), {'mod'.conPI.I.y, 'mod'.firOrd.y}, fill(0.0,0), zeroOffset, {oveWriSet_activate}, fill(0,0), {89}, fill(0,0), {87, 88}, {536871021}, fill(0,0), {85});
  end if;
  if initial() then
    der('mod'.firOrd.y) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.TSet.k, 'mod'.conPI.Dzero.k, 'mod'.conPI.P.k, 'mod'.conPI.addP.k2, 'mod'.conPI.addPID.k1, 'mod'.conPI.addPID.k2, 'mod'.conPI.addPID.k3, 'mod'.conPI.k, 'mod'.conPI.limiter.uMax, 'mod'.conPI.limiter.uMin, 'mod'.conPI.wp, 'mod'.conPI.xi_start, 'mod'.firOrd.T, 'mod'.firOrd.k, 'mod'.firOrd.y_start, oveWriAct_u, oveWriSet_u}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {oveWriAct_activate, oveWriSet_activate}, fill(0,0), {1, 23, 12, 11, 13, 14, 15, 2, 21, 22, 5, 9, 25, 24, 26, 90, 89}, fill(0,0), fill(0,0), {536871022, 536871021}, fill(0,0), {86});
  else
    der('mod'.firOrd.y) = fmi_Functions.GetRealVariable(fmi, myTime, {oveWriAct_u, oveWriSet_u}, fill(0.0,0), {'mod'.conPI.I.y, 'mod'.firOrd.y}, fill(0.0,0), zeroOffset, {oveWriAct_activate, oveWriSet_activate}, fill(0,0), {90, 89}, fill(0,0), {87, 88}, {536871022, 536871021}, fill(0,0), {86});
  end if;
  if initial() then
    rea = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'mod'.firOrd.y_start}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {26}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {91});
  else
    rea = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {'mod'.firOrd.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {88}, fill(0,0), fill(0,0), {91});
  end if;
{'mod'.conPI.I.u, 'mod'.conPI.P.u, 'mod'.conPI.P.y, 'mod'.conPI.addI.u1, 'mod'.conPI.addI.u3, 'mod'.conPI.addPID.y, 'mod'.conPI.addSat.u1, 'mod'.conPI.addSat.u2, 'mod'.conPI.addSat.y, 'mod'.conPI.controlError, 'mod'.firOrd.u, 'mod'.oveWriAct.swi.u1, 'mod'.oveWriSet.swi.u1} = fmi_Functions.fmiGetRealwf(fmi, {95, 93, 94, 100, 97, 96, 101, 98, 99, 92, 102, 104, 103}, if initial() then myTimeStart else myTime);
//alias Declarations
  'mod'.conPI.addP.u1 = 'mod'.conPI.addI.u1;
  'mod'.conPI.u_s = 'mod'.conPI.addI.u1;
  'mod'.oveWriSet.swi.y = 'mod'.conPI.addI.u1;
  'mod'.oveWriSet.y = 'mod'.conPI.addI.u1;
  'mod'.conPI.limiter.y = 'mod'.conPI.addSat.u1;
  'mod'.conPI.y = 'mod'.conPI.addSat.u1;
  'mod'.oveWriAct.swi.u3 = 'mod'.conPI.addSat.u1;
  'mod'.oveWriAct.u = 'mod'.conPI.addSat.u1;
  'mod'.oveWriAct.swi.y = 'mod'.firOrd.u;
  'mod'.oveWriAct.y = 'mod'.firOrd.u;
  'mod'.oveWriSet.uExt.y = 'mod'.oveWriSet.swi.u1;
  'mod'.oveWriAct.uExt.y = 'mod'.oveWriAct.swi.u1;
  'mod'.conPI.addPID.u3 = 'mod'.conPI.I.y;
  'mod'.conPI.addI.u2 = 'mod'.firOrd.y;
  'mod'.conPI.addP.u2 = 'mod'.firOrd.y;
  'mod'.conPI.u_m = 'mod'.firOrd.y;
  'mod'.rea.u = 'mod'.firOrd.y;
  'mod'.rea.y = 'mod'.firOrd.y;
  'mod'.conPI.addP.y = 'mod'.conPI.P.u;
  'mod'.conPI.addPID.u1 = 'mod'.conPI.P.y;
  'mod'.conPI.addI.y = 'mod'.conPI.I.u;
  'mod'.conPI.gainPID.u = 'mod'.conPI.addPID.y;
  'mod'.conPI.gainTrack.y = 'mod'.conPI.addI.u3;
  'mod'.conPI.gainPID.y = 'mod'.conPI.addSat.u2;
  'mod'.conPI.limiter.u = 'mod'.conPI.addSat.u2;
  'mod'.conPI.gainTrack.u = 'mod'.conPI.addSat.y;
  'mod'.oveWriSet.swi.u2 = 'mod'.oveWriSet.activate.y;
  'mod'.oveWriAct.swi.u2 = 'mod'.oveWriAct.activate.y;
  annotation (__Dymola_FMUImportVersion="Dymola 2019",    Icon(graphics={
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 2.0 ME")}),
Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 2.0</li>
<li>modelName = TestOverWrite.ExportedModel</li>
<li>generationTool = JModelica.org</li>
<li>generationDateAndTime = 2018-11-08T17:11:21</li>
</ul>
<p><br><b>Model Exchange Attributes</b></p>
<ul>
<li>needsExecutionTool = false</li>
<li>completedIntegratorStepNotNeeded = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = true</li>
<li>canNotUseMemoryManagementFunctions = false</li>
<li>canGetAndSetFMUstate = false</li>
<li>canSerializeFMUstate = false</li>
<li>providesDirectionalDerivative = false</li>
</ul>
</html>"));
end TestOverWrite_ExportedModel_fmu;
